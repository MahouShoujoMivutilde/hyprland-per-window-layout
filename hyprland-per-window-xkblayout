#!/usr/bin/env bash
#
# Hyprland per window xkb layout
#
# How it works:
#
# At script's launch every window (if any) gets its defined layout as currently selected.
#
# When new windows is opened the current layout is used.
# When existing window is selected - its defined layout is used.

set -e

# OPTIONS (fill with your values!)
DEBUG=true

# keyboard device from hyprland.conf where you define `kb_layout`
# in lowercase, spaces as `-`
keyboard="logitech-usb-keyboard"

# map long layout names to short ones, as displayed in
# `hyprctl devices -j | gojq -r '.keyboards | .[] | .active_keymap' | sort -u`
# when selecting different layouts
declare -A layouts_short=(["English (US)"]="us" ["Russian"]="ru")

#
# -------------------------------------------------------
#

print_debug() {
    if $DEBUG; then
        if command -v lolcat >/dev/null; then
            echo -e "$@" | lolcat
        else
            echo -e "LOG:" "$@"
        fi
    fi
}

get_active_layout() {
    local layout_fullname="$(
        hyprctl devices -j |
            gojq -r "
            .keyboards
            | .[]
            | select(.name == \"$keyboard\")
            | .active_keymap"
    )"

    echo "${layouts_short[$layout_fullname]}"
}

# addr to layout map
declare -A windows

# predefine current layout for all windows
layout="$(get_active_layout)"

for addr in $(hyprctl clients -j | gojq -r '.[] | .address'); do
    windows[$addr]="$layout"
    print_debug "define window $addr layout as $layout"
done

# declare -p windows

# window addr
current=null

# to ignore `activelayout` events generated by script itself
from_script=false

# FIXME eww this looks horrible {{{
# kb_layout, but as an array that we can index
read -r -a kb_layout_arr < <(
    hyprctl devices -j |
        gojq -r "
            .keyboards
            | .[]
            | select(.name == \"$keyboard\")
            | .layout" |
        tr ',' ' '
)

# short layout names to index
declare -A kb_layout
# inverse
for index in "${!kb_layout_arr[@]}"; do
    kb_layout["${kb_layout_arr["$index"]}"]="$index"
done
# }}}

handle() {
    event="${1%%>>*}"
    event_data="${1##*>>}"

    current="$(hyprctl activewindow -j | gojq -r '.address')"

    if $DEBUG; then
        echo "$1"
    fi

    case "$event" in
    activelayout)
        local layout_fullname="${event_data#*,}"
        if ! [[ -v layouts_short["$layout_fullname"] ]]; then
            # layout can also be `error` or `none`
            # happens after using `wtype`
            return
        fi

        layout="${layouts_short["$layout_fullname"]}"

        if [[ "$current" == null ]]; then
            return
        fi
        if $from_script; then
            from_script=false
            return
        fi

        windows["$current"]="$layout"

        print_debug "define layout for window $current as $layout"
        ;;

    createworkspace)
        current=null
        print_debug "empty ws, set current as $current"
        ;;

    openwindow)
        local open_addr="0x${event_data%%,*}"
        windows["$open_addr"]="$layout"
        print_debug "open window $open_addr, define layout as $layout"
        ;;

    activewindow)
        if [[ -v windows["$current"] ]]; then
            # loading saved layout
            local short="${windows[$current]}"
            local index="${kb_layout[$short]}"

            print_debug "window $current with defined layout $short (current is $layout)"

            if [[ "$layout" == "$short" ]]; then
                return
            fi

            from_script=true
            hyprctl switchxkblayout "$keyboard" "$index"

            layout="$short"
            print_debug "RESTORED layout $short ($index)"
        else
            print_debug "window $current without saved layout? WTF"
        fi
        ;;

    closewindow)
        local close_addr="0x${event_data}"
        unset windows["$close_addr"]
        print_debug "clear window $close_addr from map"
        ;;
    esac
}

print_debug "\noptions set:\n"

print_debug "DEBUG = $DEBUG, keyboard = $keyboard"
print_debug "layouts_short = $(declare -p layouts_short)"
print_debug "(inferred) kb_layout = $(declare -p kb_layout)"

print_debug "\n...waiting for new events...\n"

hl_instance="/tmp/hypr/$HYPRLAND_INSTANCE_SIGNATURE"

socat - \
    UNIX-CONNECT:"$hl_instance/.socket2.sock" |
    while read -r line; do
        handle "$line"
    done

# vim:foldmethod=marker
